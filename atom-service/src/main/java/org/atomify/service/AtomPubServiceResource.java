/**
 * Copyright (c) 2009 Stephan Schloepke and innoQ Deutschland GmbH
 *
 * Stephan Schloepke: http://www.schloepke.de/
 * innoQ Deutschland GmbH: http://www.innoq.com/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.atomify.service;

import java.lang.reflect.Method;
import java.net.URI;
import java.security.Principal;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.core.UriBuilder;
import javax.ws.rs.core.UriInfo;
import javax.ws.rs.core.Response.Status;

import org.atomify.model.publishing.AtomPubAccept;
import org.atomify.model.publishing.AtomPubCollection;
import org.atomify.model.publishing.AtomPubCollectionBuilder;
import org.atomify.model.publishing.AtomPubService;
import org.atomify.model.publishing.AtomPubServiceBuilder;
import org.atomify.model.publishing.AtomPubWorkspace;
import org.atomify.model.publishing.AtomPubWorkspaceBuilder;
import org.atomify.model.syndication.AtomText;
import org.atomify.service.annotations.AtomPubServiceEntry;
import org.jbasics.types.tuples.Triplet;

/**
 * A resource representing an atom publishing service document.
 * <p>
 * Derive your personal resource document from this one. In order to let this resource generate your
 * classes you need to actually implement the {@link #getServiceClasses()} method. The returned
 * classes need to be annotated with {@link AtomPubServiceEntry} on either class level or method
 * level. The URI is generated by the {@link Path} annotations from JAX-RS.
 * </p>
 * 
 * @author Stephan Schloepke
 * @since 1.0
 */
public abstract class AtomPubServiceResource {
	private final boolean requiresPrincipal;

	public AtomPubServiceResource() {
		this(false);
	}

	public AtomPubServiceResource(boolean requiresPrincipal) {
		this.requiresPrincipal = requiresPrincipal;
	}

	/**
	 * Returns the atom publishing service document as JAXB type to be marshaled by JAX-RS.
	 * 
	 * @return The atom publishing service document as JAXB type.
	 */
	@GET
	@Produces(AtomPubService.MEDIA_TYPE_STRING)
	public final AtomPubService getServiceDocument(@Context SecurityContext securityCtx, @Context UriInfo uriInfo) {
		if (this.requiresPrincipal && (securityCtx == null || securityCtx.getUserPrincipal() == null)) {
			throw new WebApplicationException(Status.FORBIDDEN);
		}
		return generateServiceDocument(securityCtx == null ? null : securityCtx.getUserPrincipal(), uriInfo.getAbsolutePathBuilder(),
				getServiceClasses());
	}

	/**
	 * Returns the service document as HTML for easier reviewing in a browser not supporting atom
	 * publishing fully.
	 * 
	 * @return The html representation of the atom publishing service document.
	 */
	@GET
	@Produces(MediaType.TEXT_HTML)
	public final String getServiceDocumentAsHtml(@Context SecurityContext securityCtx, @Context UriInfo uriInfo) {
		AtomPubService service = getServiceDocument(securityCtx, uriInfo);
		StringBuilder builder = new StringBuilder();
		builder.append("<html>\n");
		builder.append("\t<head>\n");
		builder.append("\t\t<title>Service Document</title>\n");
		builder.append("\t</head>\n");
		builder.append("\t<body>\n");
		builder.append("\t</body>\n");
		builder.append("</html>\n");
		for (AtomPubWorkspace workspace : service.getWorkspaces()) {
			builder.append("<p><h1>Workspace: ").append(workspace.getTitle().toString()).append("</h1>\n<ul>");
			for (AtomPubCollection collection : workspace.getCollections()) {
				builder.append("<li><a href=\"").append(collection.getHref()).append("\">").append(collection.getTitle().toString()).append(
						"</a></li>\n");
			}
			builder.append("</ul></p>\n");
		}
		builder.append("</body></html>");
		return builder.toString();
	}

	/**
	 * Returns the classes which are annotated with {@link AtomPubServiceEntry} on either class
	 * level or method level. Must be implemented by the derived class.
	 * 
	 * @return The classes with the services annotated with {@link AtomPubServiceEntry}.
	 */
	protected abstract Set<Class<?>> getServiceClasses();

	/**
	 * Returns the map of parameters used in the UriBuilder to build the uris for all entries in the
	 * atom service document. This should usually be dependent on a request based thread
	 * information. The default returns an empty map;
	 * 
	 * @return The map of uri parameters to be used in the uri builder for all sub path resources
	 *         (key = value pairs, defaults to empty map)
	 */
	protected Map<String, ? extends Object> getUriParameterMap() {
		return Collections.emptyMap();
	}

	private AtomPubService generateServiceDocument(final Principal principal, final UriBuilder uriBuilder, final Set<Class<?>> clazzes) {
		Map<Triplet<String, String, URI>, AtomPubCollectionBuilder> builders = new HashMap<Triplet<String, String, URI>, AtomPubCollectionBuilder>();
		for (Class<?> clazz : clazzes) {
			AtomPubServiceEntry atomService = clazz.getAnnotation(AtomPubServiceEntry.class);
			if (atomService != null) {
				addCollection(builders, atomService, clazz, null, uriBuilder.clone());
			}
			for (Method method : clazz.getMethods()) {
				atomService = method.getAnnotation(AtomPubServiceEntry.class);
				if (atomService != null) {
					addCollection(builders, atomService, clazz, method, uriBuilder.clone());
				}
			}
		}
		// TODO: Now we have scanned everything. What we need to do now is create the document. It
		// would be wise if some way we can keep
		// the state of what we scanned to quicker build the document when required. Especially when
		// building the document dynamically rather
		// than being statically.
		Map<String, AtomPubWorkspaceBuilder> workspaces = new HashMap<String, AtomPubWorkspaceBuilder>();
		for (Map.Entry<Triplet<String, String, URI>, AtomPubCollectionBuilder> entry : builders.entrySet()) {
			String workspaceTitle = entry.getKey().left();
			AtomPubWorkspaceBuilder workspace = workspaces.get(workspaceTitle);
			if (workspace == null) {
				workspace = AtomPubWorkspace.newBuilder();
				workspace.setTitle(AtomText.newBuilder().setTextContent(workspaceTitle).build());
				workspaces.put(workspaceTitle, workspace);
			}
			workspace.addCollection(entry.getValue().build());
		}
		AtomPubServiceBuilder serviceBuilder = AtomPubService.newBuilder();
		for (AtomPubWorkspaceBuilder workspace : workspaces.values()) {
			serviceBuilder.addWorkspace(workspace.build());
		}
		return serviceBuilder.build();
	}

	private void addCollection(Map<Triplet<String, String, URI>, AtomPubCollectionBuilder> builders, AtomPubServiceEntry service, Class<?> clazz,
			Method method, UriBuilder uriBuilder) {
		if (clazz != null && clazz.getAnnotation(Path.class) != null) {
			uriBuilder.path(clazz);
		}
		if (method != null && method.getAnnotation(Path.class) != null) {
			uriBuilder.path(method);
		}
		// Now we have the UriBuilder set to the right URI. Main problem will be knowing what items
		// to set.
		URI href = uriBuilder.buildFromEncodedMap(getUriParameterMap());
		Triplet<String, String, URI> key = new Triplet<String, String, URI>(service.workspace(), service.collection(), href);
		AtomPubCollectionBuilder builder = builders.get(key);
		if (builder == null) {
			builder = AtomPubCollection.newBuilder();
			builder.setTitle(AtomText.newBuilder().setTextContent(key.second()).build());
			builder.setHref(key.third());
			builders.put(key, builder);
		}
		if (method != null) {
			POST post = method.getAnnotation(POST.class);
			if (post != null) {
				// now we only can set the accept type here
				Consumes temp = method.getAnnotation(Consumes.class);
				if (temp != null) {
					for (String accept : temp.value()) {
						builder.addAccept(AtomPubAccept.valueOf(accept));
					}
				} else if (clazz != null) {
					temp = clazz.getAnnotation(Consumes.class);
					if (temp != null) {
						for (String accept : temp.value()) {
							builder.addAccept(AtomPubAccept.valueOf(accept));
						}
					}
				}
			}
		}
	}

}
