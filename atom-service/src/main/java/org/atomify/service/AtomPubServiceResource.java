/*
 * Copyright (c) 2009-2016 Stephan Schloepke
 *
 * Stephan Schloepke: http://www.schloepke.de/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package org.atomify.service;

import java.io.IOException;
import java.lang.reflect.Method;
import java.net.URI;
import java.net.URL;
import java.security.Principal;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.WebApplicationException;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.SecurityContext;
import javax.ws.rs.core.UriBuilder;
import javax.ws.rs.core.UriInfo;
import javax.ws.rs.core.Response.ResponseBuilder;
import javax.ws.rs.core.Response.Status;

import org.jbasics.arrays.ArrayConstants;
import org.jbasics.net.http.HTTPHeaderConstants;
import org.jbasics.net.http.browser.WebBrowserType;
import org.jbasics.types.tuples.Triplet;
import org.jbasics.xml.types.XmlStylesheetProcessInstruction;

import org.atomify.model.AtomDocument;
import org.atomify.model.AtomStylesheetAttachedDocument;
import org.atomify.model.publishing.AtomPubAccept;
import org.atomify.model.publishing.AtomPubCollection;
import org.atomify.model.publishing.AtomPubCollectionBuilder;
import org.atomify.model.publishing.AtomPubService;
import org.atomify.model.publishing.AtomPubServiceBuilder;
import org.atomify.model.publishing.AtomPubWorkspace;
import org.atomify.model.publishing.AtomPubWorkspaceBuilder;
import org.atomify.model.syndication.AtomText;
import org.atomify.service.annotations.AtomPubServiceEntry;

/**
 * A resource representing an atom publishing service document.
 * <p>
 * Derive your personal resource document from this one. In order to let this resource generate your classes you need to
 * actually implement the {@link #getServiceClasses()} method. The returned classes need to be annotated with
 * {@link AtomPubServiceEntry} on either class level or method level. The URI is generated by the {@link Path}
 * annotations from JAX-RS.
 * </p>
 * 
 * @author Stephan Schloepke
 * @since 1.0
 */
public abstract class AtomPubServiceResource {
	public final static MediaType XSL_MEDIA_TYPE = new MediaType("text", "xsl"); //$NON-NLS-1$ //$NON-NLS-2$
	private final boolean requiresPrincipal;

	public AtomPubServiceResource() {
		this(false);
	}

	public AtomPubServiceResource(final boolean requiresPrincipal) {
		this.requiresPrincipal = requiresPrincipal;
	}

	/**
	 * Returns the atom publishing service document as JAXB type to be marshaled by JAX-RS.
	 * 
	 * @return The atom publishing service document as JAXB type.
	 */
	@GET
	@Produces( { AtomPubService.MEDIA_TYPE_STRING, MediaType.APPLICATION_XML })
	public final Response getServiceDocument(@Context final SecurityContext securityCtx, @Context final UriInfo uriInfo,
			@Context final HttpHeaders headers) {
		if (this.requiresPrincipal && (securityCtx == null || securityCtx.getUserPrincipal() == null)) {
			throw new WebApplicationException(Status.FORBIDDEN);
		}
		AtomDocument serviceDocument = generateServiceDocument(securityCtx == null ? null : securityCtx.getUserPrincipal(), uriInfo
				.getAbsolutePathBuilder(), getServiceClasses());
		URI xsltLink = getStylesheetLink(uriInfo);
		if (xsltLink != null) {
			serviceDocument = new AtomStylesheetAttachedDocument(serviceDocument, new XmlStylesheetProcessInstruction(
					AtomPubServiceResource.XSL_MEDIA_TYPE.toString(),
					xsltLink));
		}
		ResponseBuilder temp = Response.ok(serviceDocument);
		List<String> userAgent = headers.getRequestHeader(HTTPHeaderConstants.USER_AGENT_HEADER);
		if (userAgent != null && userAgent.size() > 0) {
			WebBrowserType browser = WebBrowserType.detect(userAgent.get(0));
			if (browser == WebBrowserType.INTERNET_EXPLORER) {
				// Now the internet explorer uses a */* accept header. In such a case we want to send back xml rather
				// than atom
				temp.type(MediaType.APPLICATION_XML_TYPE);
			}

		}
		return temp.build();
	}

	/**
	 * Returns the service document as HTML for easier reviewing in a browser not supporting atom
	 * publishing fully.
	 * 
	 * @return The html representation of the atom publishing service document.
	 */
	@GET
	@Produces(MediaType.TEXT_HTML)
	public final String getServiceDocumentAsHtml(@Context final SecurityContext securityCtx, @Context final UriInfo uriInfo) {
		if (this.requiresPrincipal && (securityCtx == null || securityCtx.getUserPrincipal() == null)) {
			throw new WebApplicationException(Status.FORBIDDEN);
		}
		AtomPubService service = generateServiceDocument(securityCtx == null ? null : securityCtx.getUserPrincipal(), uriInfo
				.getAbsolutePathBuilder(), getServiceClasses());
		StringBuilder builder = new StringBuilder();
		builder.append("<html>\n");
		builder.append("\t<head>\n");
		builder.append("\t\t<title>Service Document</title>\n");
		builder.append("\t</head>\n");
		builder.append("\t<body>\n");
		builder.append("\t</body>\n");
		builder.append("</html>\n");
		for (AtomPubWorkspace workspace : service.getWorkspaces()) {
			builder.append("<p><h1>Workspace: ").append(workspace.getTitle().toString()).append("</h1>\n<ul>");
			for (AtomPubCollection collection : workspace.getCollections()) {
				builder.append("<li><a href=\"").append(collection.getHref()).append("\">").append(collection.getTitle().toString()).append(
						"</a></li>\n");
			}
			builder.append("</ul></p>\n");
		}
		builder.append("</body></html>");
		return builder.toString();
	}

	@Path("stylesheet.xslt")
	@Produces( { "application/xslt+xml", MediaType.APPLICATION_XML })
	public final Response getStylesheetDocument() {
		URL data = getHtmlTransformStylesheetURI();
		if (data == null) {
			return Response.status(Status.NOT_FOUND).build();
		}
		try {
			return Response.ok(data.openStream()).build();
		} catch (IOException e) {
			throw new WebApplicationException(e, Status.INTERNAL_SERVER_ERROR);
		}
	}

	/**
	 * Returns the classes which are annotated with {@link AtomPubServiceEntry} on either class
	 * level or method level. Must be implemented by the derived class.
	 * 
	 * @return The classes with the services annotated with {@link AtomPubServiceEntry}.
	 */
	protected abstract Set<Class<?>> getServiceClasses();

	/**
	 * Returns the map of parameters used in the UriBuilder to build the uris for all entries in the
	 * atom service document. This should usually be dependent on a request based thread
	 * information. The default returns an empty map;
	 * 
	 * @return The map of uri parameters to be used in the uri builder for all sub path resources
	 *         (key = value pairs, defaults to empty map)
	 */
	protected Map<String, ? extends Object> getUriParameterMap() {
		return Collections.emptyMap();
	}

	/**
	 * Returns the URI which is World accessible to attach as a stylesheet link to the atom
	 * document.
	 * 
	 * @param uriInfo
	 * @return
	 */
	protected URI getStylesheetLink(final UriInfo uriInfo) {
		if (getHtmlTransformStylesheetURI() != null) {
			try {
				return uriInfo.getRequestUriBuilder().path(
						getClass().getMethod("getStylesheetDocument", (Class<?>[]) ArrayConstants.ZERO_LENGTH_OBJECT_ARRAY)).build();
			} catch (NoSuchMethodException e) {
				// Ignore and do not return an URI
			}
		}
		return null;
	}

	protected URL getHtmlTransformStylesheetURI() {
		return getClass().getResource("atom-html-transform.xslt");
	}

	private AtomPubService generateServiceDocument(final Principal principal, final UriBuilder uriBuilder, final Set<Class<?>> clazzes) {
		Map<Triplet<String, String, URI>, AtomPubCollectionBuilder> builders = new HashMap<Triplet<String, String, URI>, AtomPubCollectionBuilder>();
		for (Class<?> clazz : clazzes) {
			AtomPubServiceEntry atomService = clazz.getAnnotation(AtomPubServiceEntry.class);
			if (atomService != null) {
				addCollection(builders, atomService, clazz, null, uriBuilder.clone());
			}
			for (Method method : clazz.getMethods()) {
				atomService = method.getAnnotation(AtomPubServiceEntry.class);
				if (atomService != null) {
					addCollection(builders, atomService, clazz, method, uriBuilder.clone());
				}
			}
		}
		// TODO: Now we have scanned everything. What we need to do now is create the document. It
		// would be wise if some way we can keep
		// the state of what we scanned to quicker build the document when required. Especially when
		// building the document dynamically rather
		// than being statically.
		Map<String, AtomPubWorkspaceBuilder> workspaces = new HashMap<String, AtomPubWorkspaceBuilder>();
		for (Map.Entry<Triplet<String, String, URI>, AtomPubCollectionBuilder> entry : builders.entrySet()) {
			String workspaceTitle = entry.getKey().left();
			AtomPubWorkspaceBuilder workspace = workspaces.get(workspaceTitle);
			if (workspace == null) {
				workspace = AtomPubWorkspace.newBuilder();
				workspace.setTitle(AtomText.newBuilder().setTextContent(workspaceTitle).build());
				workspaces.put(workspaceTitle, workspace);
			}
			workspace.addCollection(entry.getValue().build());
		}
		AtomPubServiceBuilder serviceBuilder = AtomPubService.newBuilder();
		for (AtomPubWorkspaceBuilder workspace : workspaces.values()) {
			serviceBuilder.addWorkspace(workspace.build());
		}
		return serviceBuilder.build();
	}

	private void addCollection(final Map<Triplet<String, String, URI>, AtomPubCollectionBuilder> builders, final AtomPubServiceEntry service,
			final Class<?> clazz,
			final Method method, final UriBuilder uriBuilder) {
		if (clazz != null && clazz.getAnnotation(Path.class) != null) {
			uriBuilder.path(clazz);
		}
		if (method != null && method.getAnnotation(Path.class) != null) {
			uriBuilder.path(method);
		}
		// Now we have the UriBuilder set to the right URI. Main problem will be knowing what items
		// to set.
		URI href = uriBuilder.buildFromEncodedMap(getUriParameterMap());
		Triplet<String, String, URI> key = new Triplet<String, String, URI>(service.workspace(), service.collection(), href);
		AtomPubCollectionBuilder builder = builders.get(key);
		if (builder == null) {
			builder = AtomPubCollection.newBuilder();
			builder.setTitle(AtomText.newBuilder().setTextContent(key.second()).build());
			builder.setHref(key.third());
			builders.put(key, builder);
		}
		if (method != null) {
			POST post = method.getAnnotation(POST.class);
			if (post != null) {
				// now we only can set the accept type here
				Consumes temp = method.getAnnotation(Consumes.class);
				if (temp != null) {
					for (String accept : temp.value()) {
						builder.addAccept(AtomPubAccept.valueOf(accept));
					}
				} else if (clazz != null) {
					temp = clazz.getAnnotation(Consumes.class);
					if (temp != null) {
						for (String accept : temp.value()) {
							builder.addAccept(AtomPubAccept.valueOf(accept));
						}
					}
				}
			}
		}
	}

}
